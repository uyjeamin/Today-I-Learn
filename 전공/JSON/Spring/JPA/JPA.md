**JPA**

1. *_JPA(Java Persistence API): 자바 _영속성 API를 말함.__

***영속성** : 데이터를 생성한 프로그램이 종료되어도 사라지지 않는 데이터의 특성.

JPA는 자바에서 사용하는 *ORM 의 한 종류이고, 자바에서 관계형데이터베이스(RDB) 를 사용하는 방식을 정의한 인터페이스이다.

1. ***ORM(object-relational mapping) 이란?**
    
    ORM 은 자바의 객체와 데이터베이스를 Mapping(연결) 하는 프로그래밍 기법이다.
    

`ex : 데이터베이스 에서 age, name 속성에 20, 홍길동이라는 값이 들어있다 이때 자바에선 이 값을 사용하기 위하여 ORM 이용해 데이터베이스 의 값을 마치 객체처럼 사용 가능 ⇒ SQL을 전혀 몰라도 자바 언어로만 데이터베이스에 접근해서 원하는 값을 받아올수 있다`

![[Untitled1.png]]
즉, 객체와 데이터베이스를 연결 ⇒ 자바 언어로만 데이터베이스를 다룰수 있게하는 도구를 ORM 이라고 한다.

1. *하이버네이트(Hibermate)이란?

JPA의 인터페이스를 구현한 구현자이자 자바용 ORM 프레임워크. 내부적으로 JDBC API를 사용함.

JPA 는 인터페이스이므로 실제 사용을 위해 ORM 프레임워크를 추가로 선택해야 함. (대표적으로 *하이버네이트 를 많이 사용함.)
![[2.png]]

(EclipseLink, DataNucleus)등 다른 구현체 도 있음.

1. **Entity(개체)**

- 테이블과 매칭되는 개념
- ORM 을 이루는 기반 개념 중 하나. 객체와 RDB 간 연결시켜주는 존재

> 엔터티(Entity)는 현실세계의 정보를 표현하는 단위로, 현실세계의 대상체를 나타냄.

엔티티는 "어떤 것(Thing)"이라고 말할 수 있다. "어떤 것"이라고 부르는 것처럼 엔터티는 추상적인 의미를 가지며 학교나 학생처럼 현실 세계에서 눈에 보이는 개념일 수도 있고 주문이나 결제처럼 눈에 보이지 않는 개념일 수도 있다.

![https://blog.kakaocdn.net/dn/XFTzg/btrP33sIF6G/OFa6qQtomfPrkUyWmhVeM1/img.png](https://blog.kakaocdn.net/dn/XFTzg/btrP33sIF6G/OFa6qQtomfPrkUyWmhVeM1/img.png)

**엔터티(Entity) :** 엔터티는 데이터베이스 테이블이라고 생각하면 이해가 편하다.

1. **EntityManager**

- 엔티티를 관리하는 역할을 한다.
- 엔티티 매니저 내부에는 영속성 컨텍스트가 있으며, 이를 통해 엔티티를 관리.
- 여러 엔티티 매니저가 하나의 영속성 컨텍스트를 공유 가능
- EntityManager 는 [[Thread-safe]] 를 보장해야 함. 동일한 Entitymanager 를 가지고 멀티 스레드 환경에서 호출한다면 데이터가 어떻게 변경될지 모름.

1. **[[영속성 컨텍스트]]**

> 엔티티를 영구히 저장하는 환경 어플리케이션과 데이터베이스 사이에서 객체를 보관하는 **가상의 데이터베이스** 같은 역활을 함. 엔티티 매니저를 통해 엔티티를 저장하거나 조회하면 엔티티 매니저는 영속성 컨텍스트에 엔티티를 보관하고 관리한다.

엔티티를 바로 DB 에 저장하지 않고 영속성 컨텍스트에 거치면서 얻는 장점. 트랙젝션 활용 가능 ,변경감지 ,1차 캐시

### 엔티티의 생명주기

- 비영속(new/transient): 영속성 컨텍스트와 전혀 관계가 없는 상태,POJO 상태 
```java
Member member = new Member();
```

- 영속(managed): 영속성 컨텍스트에 저장된 상태
```java
em.persist(member); // 객체 저장
```

- 준영속(detached): 영속성 컨텍스트에 저장되었다가 분리된 상태

영속 상태의 엔티티가 분리된 상태 ->Dirty Chenking 이나 변경 감지 등의 영속성 컨텍스트가 제공하는 기능을 사용할 수 없다.

**거의 비영속 상태와 동일함.**

```java
em.detach(member); // 특정 엔티티를 분리

em.close(); // 영속성 컨텍스트 닫기
em.clear(); // 영속성 컨텍스트 초기화
```

- 삭제(removed): 삭제된 상태
```java
em.remove(member);
```

1. **JPA는 어떻게 작동할까?**

JPA는 어플리케이션과 JDBC 사이에서 동작한다. 어플리케이션에서 JPA로 명령을 하면 JPA가 해석해서 JDBC를 사용해 SQL을 실행하고 그 결과를 반환받는다.

💡**JDBC(Jaca Database Connectivity)란?**

> 자바에서 데이터베이스에 접속할 수 있도록 하는 자바 API이다.

ex : findAll() 이라는 자바스러운 메소드를 사용 ⇒ 변환 ⇒ SELECT* ~~ 와 같은 쿼리가 발생한다.

![[4.png]]

이러한 SQL 중심적이 아닌 객체를 중심적으로 개발할 수 있는 것이 엄청 큰 장점이라 생각한다.

findAll과 같은 메소드는 spring-boot-starter-data-jpa이다. 실제 jpa는 아래와 같은 메소드로 CRUD 작업을 한다.

***CRUD**는 “**Create, Read, Update, Delete**”의 약어 데이터베이스의 기본적인 데이터 관리 기능

- **저장 : jpa.persist(member)**
- **조회 : Member member = jpa.find(memberld)**
- **수정 : member.setName(”변경할 이름”)**
- **삭제 : jpa.remove(member)**

💡 **JPA를 사용해야 하는 이유**

**생산성**

- SQL 문을 작성하고 JDBC API 를 사용하는 지루하고 반복적인 일을 JPA 가 대신 처리해준다.

**유지보수**

새로운 필드가 추가되거나 삭제되었을 때,관련된 SQL과 JDBC 코드를 모수 수정해야 하는 번거로움을 줄일수 있다.

### **패러다임 불일치 해결**

💡 **페러다임 불일치란?**

> 객체가 단순하면 객체의 모든 속성값을 파일이나 DB에 저장하면 되지만 부모객체를 상속받았거나, 다른 객체를 참조하고 있다면 객체의 상태를 저장하기는 쉽지 않다 그래서 RDB 에 저장하는 것이 최선의 선택이다.

하지만 RDB는 데이터 중심으로 구조화, 집합적인 사고를 요구함 (객체지향에서의 추상화,상속,다형성 같은 개념이 없다.) ⇒서로 지향하는 목적과 표현 기능, 표현방법이 다르다 이것을 객체와 RDB 의 **페러다임 불일치 문제**라 함.

이런 객체 지향적인 개념들을 데이터베이스에서 매핑해주어, 페러다임 불일치를 해결함.

- 페러다임 불일치 해결 하면 유연하고 유지보수 하기 쉬운 도메인을 만들수 있다.

**최적화**

- 다양한 성능 최적화 기회 제공함.
- 어플리케이션 과 DB 사이에 존재함으로 여러 최적화 시도 가능.

**데이터 접근 추상화와 벤더 독립성**

- 데이터베이스 기술에 종속되지 않도록 함
- 데이터베이스를 변경하면 JPA에게 다른 데이터베이스를 사용한다고 알려주면 됨. ⇒ 데이터베이스를 쉽게 변경할수 있다.
