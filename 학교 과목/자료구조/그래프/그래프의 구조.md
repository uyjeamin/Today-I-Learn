## 완전그래프
* 각 정점에서 다른 모든 정점을 연결하여 최대로 많은 간선 수를 가진 그래프
* 정점이 n개인 무방향 그래프에서 최대의 간선 수: n(n-1)/2개
* 정점이 n개인 방향 그래프의 최대 간선 수: n(n-1)개

## 부분 그래프
* 원래의 그래프에서 정점이나 간선을 일부만 제외하여 만든 그래프
* 그래프 G와 부분 그래프G'의 관계
`` V(G') 같거나 작다 V(G), E(G') 같거나 작다 E(G)


## 너비우선 탐색
>1. 시작 정점 v를 결정하여 방문한다.
>2. 정점 v에 인접한 정점중에서 방문하지 않은 정점을 차례로 방문하면서 큐에 enQueue 한다.
>3. 방문하지 않은 인접한 정점이 없으면, 방문했던 정점에서 인접한 정점을 다시 차례로 방문하기 위해 큐에서 deQueue 하여 받은 정점을 v로 설정하고 2 를 반복한다.
>4. 큐가 공백이 될 때까지 2~3 을 반복한다.


트리와 그래프의 차이점
>트리는 사이클이 없지만 그래프는 사이클이 생긴다.

### 최소비용 신장트리 만들기 
##### 크루스칼 알고리즘 1
>가중치가 가장높은 간선을 제거함, 하지만 제거하면 트리가 끊기는 간선은 제거하면 안된다.(간선의 가중치를 정렬한 후 시작함.)

##### 크루스칼 알고리즘 2
>가중치가 가장낮은 간선을 삽입함, 하지만 삽입시 사이클이 생기는 간선은 삽입하지 않는다.(간선의 가중치를 정렬한 후 시작함.)

##### 프림알고리즘
>시작 정점에서 가장 가중치가 낮은 간선을 선택해 확장해 나가는 방식, 간선을 선택하면 그 간선으로 연결된 노드에서 가장 가중치가 낮은 간선을 선택함.



### 다익스트라 최단 경로 알고리즘
* 하나의 시작정점에서 다른 정점까지의 최단 경로를 구함
* 단일점에서의 최단경로 알고리즘중 가장 많이 사용.
* 무방향 그래프나 방향 그래프에 모두 적용 가능

순서
1. **경로 길이를 저장할 배열 distance 준비** : 시작 정점으로 부터 각 정점에 이르는 경로의 길이를 저장하기 위한 배열 distance 를 무한대로 초기화한다.
2. **시작 정점 초기화** : 시작 정점의 distance 를 0으로 초기화 하고 집합 S 에 추가한다.
3. **최단 거리 수정** : 집합 S 에 속하지 않은 정점 중에서 distance 가 최소인 정점 u를 찾아 집합 S에 추가한다. 새로운 정점 u 가 추가되면 u에 인접하고 집합s에 포함되지 않은 정점 w의 distance 값을 다음 식에 따라 수정한다. 집합 S에 모든 정점이 추가될때까지 3 을 반복한다.

```
distance[w]<-min(distance[w],distance[u]+weight[u][w])
```


### 플로이드 최단 경로 알고리즘
* 모든 정점 사이의 최단 경로 를 구한것
* k-최단경로 - 플로이드 최단경로 알고리즘으로 만든 최단 경로
